# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: /home/dgulino/Documents/workspace/nested/src/nested.erl
# At: 2022-06-25 17:24:15

defmodule Nested do
  @moduledoc """
  Documentation for `Nested`.
  """

  @doc """
  Library to work with nested maps
  Elixir reimplementation of Erlang library [nested](https://github.com/odo/nested)

  ## Examples

      iex> Nested.get(%{test: :rest}, [:test] )
      :rest

  """

  def is_key(map, [key]) do
    Map.has_key?(map, key)
  end

  def is_key(map,[key | pathRest]) do
    case(map) do
      %{^key => subMap} ->
        is_key(subMap, pathRest)
      _ ->
        false
    end
  end


  def get(map,[key | pathRest]) do
    get(Map.get(map, key), pathRest)
  end

  def get(value, []) do
    value
  end


  def get(map, [key | pathRest], default) do
    case(:maps.get(key, map, {__MODULE__, default})) do
      {__MODULE__, ^default} ->
        default
      nestedMap ->
        get(nestedMap, pathRest, default)
    end
  end

  def get(value, [], _) do
    value
  end


  def update(map, path, valueOrFun) do
    try do
      updatef_internal(map, path, valueOrFun)
    catch
      :error, {:error, {:no_map, pathRest, element}} ->
        pathLength = length(path) - length(pathRest)
        pathToThrow = :lists.sublist(path, pathLength)
        :erlang.error({:no_map, pathToThrow, element})
    end
  end


  defp updatef_internal(map, [key | pathRest], valueOrFun) when is_map(map) do
    :maps.update(key, updatef_internal(:maps.get(key,map), pathRest, valueOrFun),map)
  end

  defp updatef_internal(oldValue, [], fun) when is_function(fun) do
    fun.(oldValue)
  end

  defp updatef_internal(_, [], value) do
    value
  end

  defp updatef_internal(element, path, _) do
    :erlang.error({:error, {:no_map, path, element}})
  end


  def put(map, [key | pathRest], value) do
    subMap = case(:maps.is_key(key, map) and is_map(:maps.get(key, map))) do
      true ->
        :maps.get(key, map)
      false ->
        %{}
    end
    :maps.put(key, put(subMap, pathRest, value), map )
  end

  def put(_, [], value) do
    value
  end


  def remove(_, []) do
    throw({:bad_path, []})
  end

  def remove(map, [lastKey]) do
    :maps.remove(lastKey, map)
  end

  def remove(map, [key | pathRest]) do
    case(:maps.is_key(key, map)) do
      true ->
        :maps.put(key, remove(:maps.get(key, map), pathRest), map)
      false ->
        map
    end
  end


  def keys(map, [key | pathRest]) do
    keys(:maps.get(key, map), pathRest)
  end

  def keys(map, []) do
    :maps.keys(map)
  end


  def append(map, path, value) do
    appendFun = fn
      list when is_list(list) ->
        list ++ [value]
      _ ->
        :erlang.error(:no_list)
    end
    update(map, path, appendFun)
  end

end
